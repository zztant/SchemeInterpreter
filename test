
(define fun (lambda (x) (if (= x 0) 0 (+ x (fun (- x 1))))))
LDF->,(LDC->,LD->,LIST->,LD->,AP->,SEL->,(LDC->,JOIN->,|LDC->,LD->,LIST->,LD->,AP->,LIST->,LD->,AP->,JOIN->,)RET->,)DEFINE->,

(define fun2 (lambda (x sum) (if (= x 0) sum (fun2 (- x 1) (+ x sum)))))

(fun 1)
LDC->,LIST->,LD->,AP->,

(define a (lambda (x) (lambda (y) (* x y))))
LDF->,(LDF->,(LD->,LD->,LIST->,LD->,AP->,RET->,)RET->,)DEFINE->,


(define b (a 10))
LDC->,LIST->,LD->,AP->,DEFINE->,

(b 10)

(define even? (lambda (x) (or (= x 0) (odd? (- x 1)))))
(define odd? (lambda (x) (and (not (= x 0)) (even? (- x 1)))))

/* 我的or和and的实现方式有问题,应该用基本指令，像IF那样把后续代码放到参数里 */

(let ((x 5))
   (define foo (lambda (y) (bar x y)))
   (define bar (lambda (a b) (+ (* a b) a)))
   (foo (+ x 3)))

( (lambda (x) (define foo (lambda (y) (bar x y)))
              (define bar (lambda (a b) (+ (* a b) a)))
			  (foo (+ x 3)))
  5)
